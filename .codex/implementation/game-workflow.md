# Game workflow

This document describes the full runtime sequence of Midori AI AutoFighter and how player progress is persisted between runs.

## Startup
- `PluginLoader` scans the `plugins/` directory and registers available classes.
- For each fighter plugin found in `plugins/players/`, the loader attempts to restore a save from `lives/<name>.dat`.
- Save files use Python's `pickle` format to serialize each fighter's `__dict__`.

## Wave preparation
- Before a wave begins, fighters level up and their updated state is written back to `lives/`.
- Foes are generated by combining adjectives and themed names, then modified by `foe_passive_builder.py`.

## Battle loop
- Waves play out automatically while fighters and foes exchange attacks.
- During combat, summaries append to `logs/<name>.txt`.
- When a fighter's HP reaches zero, `save_past_life` archives their data to `past_lives/<uuid>.pastlife` and deletes the active save.

## Run termination
- The game ends when all fighters have been defeated.
- The engine writes each fighter's final state to `lives/<name>.dat` (e.g., `lives/Ally.dat`) and exitsâ€”no manual action is required.
- On the next launch, surviving fighters or new ones resume from the data in `lives/`.
